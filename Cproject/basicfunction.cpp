/************************************标准模式函数库**************************************/

#include <stdio.h> 
#include <stdlib.h>
#include <conio.h> 
#include "basicfunction.h"

extern int a[4][4];
extern int b, M;
extern int point;
extern int point1;
extern int N;

extern int c[3][3];//3*3的方块 
extern int d[5][5];//5*5的方块 

int z[4][4] = {0};//4*4矩阵的替身 
int z3[3][3] = {0};//3*3矩阵的替身
int z5[5][5] = {0};//5*5矩阵的替身
//用在moveandadd函数里，方便将一个动作转换成4个方向
//相当于矩阵的转置、行对称、列对称或某两个的叠加 

int pointmax()
//历次游戏最高得分
{
	int i = 0, j = 0;
	//用“r”模式，先读入原有记录，分配到字符数组中 
	FILE* fptr1;
	errno_t err1 = fopen_s(&fptr1, "record345.txt", "r");
	char pt[3][10] = {0};
	if (fptr1 != NULL) {
		for (i = 0; i < 3; i++)
		{
			fgets(pt[i], 10, fptr1);
		}
		fclose(fptr1);
	}
	//对数组进行处理 
	int maxpt = 0;
	if(N == 3){
		maxpt = atoi(pt[0]);
		if(point > maxpt)
		{
			maxpt = point;
			for(j=0;j<10;j++)
			{
				pt[0][j] = 0;
			}
			sprintf_s(pt[0], "%d\n", maxpt);
		}
	}
	if(N == 4){
		maxpt = atoi(pt[1]);
		if(point > maxpt)
		{
			maxpt = point;
			for(j=0;j<10;j++)
			{
				pt[1][j] = 0;
			}
			sprintf_s(pt[1], "%d\n", maxpt);
		}
	}
	if(N == 5){
		maxpt = atoi(pt[2]);
		if(point > maxpt)
		{
			maxpt = point;
			for(j=0;j<10;j++)
			{
				pt[2][j] = 0;
			}
			sprintf_s(pt[2], "%d\n", maxpt);
		}
	}
	//用“w”模式写进文件 
	FILE* fptr2;
	errno_t err2 = fopen_s(&fptr2, "record345.txt", "w");
	if (fptr2 != NULL) {
		fputs(pt[0], fptr2);
		fputs(pt[1], fptr2);
		fputs(pt[2], fptr2);
		fclose(fptr2);
	}
	return maxpt;
}


void print()
//print函数用于打印游戏界面 
{
	system("CLS");//清空屏幕，重新打印 
	int i,j,k;
	//3*3的情况 
	if(N == 3)
	{
	    for(k=1;k<=18;k++)
	{
		printf("*");
	}
	printf("   你的得分：%d", point);
	printf("\n");
	for(i=0;i<3;i++)
	{
		printf("* ");
		for(j=0;j<3;j++)
		{
			if(c[i][j] != 0)
			{
				printf("%-5d",c[i][j]);
			}
			else
			{
				printf("     ");
			}
		}
		printf("*");
		if(i == 0) printf("   最高得分：%d", pointmax());
		printf("\n");
	}
	for(k=1;k<=18;k++)
	{
		printf("*");
	}
	printf("\n");	
	}
	//4*4的标准情况 
	if(N == 4)
	{
	    for(k=1;k<=23;k++)//第一行 
	{
		printf("*");
	}
	printf("   你的得分：%d", point);
	printf("\n");
	for(i=0;i<4;i++)//第二至五行 
	{
		printf("* ");
		for(j=0;j<4;j++)
		{
			if(a[i][j] != 0)
			{
				printf("%-5d",a[i][j]);
			}
			else
			{
				printf("     ");
			}
		}
		printf("*");
		if(i == 0) printf("   最高得分：%d", pointmax());
		printf("\n");
	}
	for(k=1;k<=23;k++)//第六行 
	{
		printf("*");
	}
	printf("\n");	
    } 
	//5*5的情况 
	if(N == 5)
	{
		for(k=1;k<=28;k++)
	{
		printf("*");
	}
	printf("   你的得分：%d", point);
	printf("\n");
	for(i=0;i<5;i++)
	{
		printf("* ");
		for(j=0;j<5;j++)
		{
			if(d[i][j] != 0)
			{
				printf("%-5d",d[i][j]);
			}
			else
			{
				printf("     ");
			}
		}
		printf("*");
		if(i == 0) printf("   最高得分：%d", pointmax());
		printf("\n");
	}
	for(k=1;k<=28;k++)
	{
		printf("*");
	}
	printf("\n");	
	}
}


int notfull()
//notfull函数用于判断是否有空格子，有的话返回1,已经填满返回0 
{
	int i,j,k = 0;
	//3*3的情况 
	if(N == 3)
	{
		for(i=0;i<3;i++)
		{
			for(j=0;j<3;j++)
			{
				if(c[i][j] == 0)
				{
					k = 1;
					break;
				}
			}
		}
	}
	//4*4的标准情况 
	if(N == 4)
	{
		for(i=0;i<4;i++)
		{
			for(j=0;j<4;j++)
			{
				if(a[i][j] == 0)
				{
					k = 1;
					break;
				}
			}
		}	
	}
	//5*5的情况 
	if(N == 5)
	{
		for(i=0;i<5;i++)
		{
			for(j=0;j<5;j++)
			{
				if(d[i][j] == 0)
				{
					k = 1;
					break;
				}
			}
		}
	}
	return k;
}


int rand10()
//百分之九十的概率产生2，百分之十的概率产生4 
{
	int y;
	y = rand();
	if(y % 10 == 0) return 4;
	if(y % 10 != 0) return 2;
}


void randomnumber()
//randomnumber函数用于在玩家进行操作过后，随机选取一个空格子，生成数字2或4 
{
	int x, y;//x表示将要生成的数字
	 
	int i, j;
	//3*3的情况 
	if(N == 3)
	{
		x = 2;//在3*3的情况下新生成的数字只可能是2 
	    do
		{
			i = rand()%3;
			j = rand()%3;
		} while(c[i][j] != 0);
		c[i][j] = x;
	}
	//4*4的标准情况 
	if(N == 4)
	{
		x = rand10();//随机生成一个数，x可以为2或者4，概率为10%和90%
	    do
		{
			i = rand()%4;
			j = rand()%4;
		} while(a[i][j] != 0);
		a[i][j] = x;	
	}
	//5*5的情况 
	if(N == 5)
	{
		x = rand10();//允许随机生成两个数，其中的x可以为2或者4，概率为10%和90%
		y = rand10();//允许随机生成两个数，其中的y可以为2或者4，概率为10%和90%
		do
		{
			i = rand()%5;
			j = rand()%5;
		} while(d[i][j] != 0);
		d[i][j] = x;

		if(notfull() == 1)
		{
			do
			{
				i = rand()%5;
				j = rand()%5;
			} while(d[i][j] != 0);
			d[i][j] = y;
		}
	}
}

	
int calculatemax()
//calculatemax函数用于获取当前数组中的最大数字
{
	int maxnumber = 2;
	int i, j;
	//3*3的情况 
	if(N == 3)
	{
		for(i=0;i<3;i++)
		{
			for(j=0;j<3;j++)
			{
				if(c[i][j] > maxnumber)
				{
					maxnumber = c[i][j];
				}
			}
		}
	}
	//4*4的标准情况 
	if(N == 4)
	{
		for(i=0;i<4;i++)
		{
			for(j=0;j<4;j++)
			{
				if(a[i][j] > maxnumber)
				{
					maxnumber = a[i][j];
				}
			}
		}
	}
	//5*5的情况 
	if(N == 5)
	{
		for(i=0;i<5;i++)
		{
			for(j=0;j<5;j++)
			{
				if(d[i][j] > maxnumber)
				{
					maxnumber = d[i][j];
				}
			}
		}
	}
	return maxnumber;
}


int move()
//move函数关联四个方向按键和相应的移动 
{
	char key = _getch(), k = 0;//k=0表示没有按方向键，k=1表示正确按了方向键 
	if(key == 'w' || key == 'W')//上 
	{
		b = 1;
		k = 1;
	}
	if(key == 'a' || key == 'A')//左 
	{
		b = 2;
		k = 1;
	}
	if(key == 's' || key == 'S')//下 
	{
		b = 3;
		k = 1;
	}
	if(key == 'd' || key == 'D')//右 
	{
		b = 4;
		k = 1;
	}
	return k;
}

	
int canstillmove()
//canstillmove函数用于判断当没有空格的时候，是否还可以再进行移动
//仍然可以移动返回1，游戏继续；不能再移动返回0，游戏结束 
{
	int k = 0;//k是预设返回值
	int i, j;
	//3*3的情况 
	if(N == 3)
	{
		for(i=0;i<3;i++)//检查左右是否有相邻的相同数字 
		{
			for(j=0;j<2;j++)
			{
				if(c[i][j] == c[i][j+1])
				{
					k = 1;
				}
			}
		}
		for(j=0;j<3;j++)//检查上下是否有相邻的相同数字 
		{
			for(i=0;i<2;i++)
			{
				if(c[i][j] == c[i+1][j])
				{
					k = 1;
				}
			}
		}
	}
	//4*4的标准情况 
	if(N == 4)
	{
	    for(i=0;i<4;i++)//检查左右是否有相邻的相同数字 
		{
			for(j=0;j<3;j++)
			{
				if(a[i][j] == a[i][j+1])
				{
					k = 1;
				}
			}
		}
		for(j=0;j<4;j++)//检查上下是否有相邻的相同数字 
		{
			for(i=0;i<3;i++)
			{
				if(a[i][j] == a[i+1][j])
				{
					k = 1;
				}
			}
		}	
	}
	//5*5的情况 
	if(N == 5)
	{
		for(i=0;i<5;i++)//检查左右是否有相邻的相同数字 
		{
			for(j=0;j<4;j++)
			{
				if(d[i][j] == d[i][j+1])
				{
					k = 1;
				}
			}
		}
		for(j=0;j<5;j++)//检查上下是否有相邻的相同数字 
		{
			for(i=0;i<4;i++)
			{
				if(d[i][j] == d[i+1][j])
				{
					k = 1;
				}
			}
		}
	}
	return k;
}


int moveandadd3()
//3*3情况 
//moveandadd函数用于进行移动和数字相加的操作
//返回1表示进行了移动，返回0表示未进行移动
{
	int k = 0;//k是预设返回值
	int i,j,pass,m;//i表示形式参数行，j表示形式参数列，pass表示检测的轮数,m表示是否进行了合并 
		if(b == 1)//向上的移动操作 
	    {
	        for(i = 0;i < 3;i++)
		    {
			    for(j = 0;j < 3;j++)
			    {
				    z3[i][j] = c[i][j];			
			    }
		    }
		
		    for(j=0;j<3;j++)
		    {
			    m = 0;
				for(pass=1;pass<=2;pass++)
				{
					for(i=1;i<3;i++)
					{
						if(z3[i-1][j] == 0 && z3[i][j] != 0)//有空位，上移 
						{
							z3[i-1][j] = z3[i][j];
							z3[i][j] = 0;
							k = 1;
						}
						if(z3[i-1][j] != 0 && z3[i-1][j] == z3[i][j] && m == 0)//无空位，还没有进行过合并，数字相同，合并相加并记录合并的类型 
						{
							m = z3[i][j];
							z3[i-1][j] = 2*z3[i][j]; point += z3[i-1][j];
							z3[i][j] = 0;
							k = 1;
						}
						if(z3[i-1][j] != 0 && z3[i-1][j] == z3[i][j] && m != 0 && z3[i][j] == m)//无空位，已经进行过合并，数字相同
						{
							z3[i-1][j] = 2*z3[i][j]; point += z3[i-1][j]; 
							z3[i][j] = 0;
							k = 1;
						}
				    }
			    }
		    }
		
			for(i = 0;i < 3;i++)
			{
				for(j = 0;j < 3;j++)
				{
					c[i][j] = z3[i][j];			
				}
			}
		}
		
		if(b == 2)//向左的移动操作
		{
			for(i = 0;i < 3;i++)
			    {
				    for(j = 0;j < 3;j++)
				    {
					    z3[i][j] = c[j][i];			
				    }
			    }
			
			    for(j=0;j<3;j++)
			    { 
				    m = 0;
					for(pass=1;pass<=2;pass++)
					{
						for(i=1;i<3;i++)
						{
							if(z3[i-1][j] == 0 && z3[i][j] != 0)
							{
								z3[i-1][j] = z3[i][j];
								z3[i][j] = 0;
								k = 1;
							}
							if(z3[i-1][j] != 0 && z3[i-1][j] == z3[i][j] && m == 0)
							{
								m = z3[i][j];
								z3[i-1][j] = 2*z3[i][j]; point += z3[i-1][j];
								z3[i][j] = 0;
								k = 1;
							}
							if(z3[i-1][j] != 0 && z3[i-1][j] == z3[i][j] && m != 0 && z3[i][j] == m)//无空位，已经进行过合并，数字相同
							{
								z3[i-1][j] = 2*z3[i][j]; point += z3[i-1][j]; 
								z3[i][j] = 0;
								k = 1;
							}
					   }
				    }
			    }
			
			for(i = 0;i < 3;i++)
			{
				for(j = 0;j < 3;j++)
				{
					c[i][j] = z3[j][i];			
				}
			}
		} 
	
		if(b == 3)//向下的移动操作 
		{
		    for(i = 0;i < 3;i++)
			    {
				    for(j = 0;j < 3;j++)
				    {
					    z3[i][j] = c[2-i][j];			
				    }
			    }
			
			    for(j=0;j<3;j++)
			    {
				    m = 0;
					for(pass=1;pass<=2;pass++)
					{
						for(i=1;i<3;i++)
						{
							if(z3[i-1][j] == 0 && z3[i][j] != 0)
							{
								z3[i-1][j] = z3[i][j];
								z3[i][j] = 0;
								k = 1;
							}
							if(z3[i-1][j] != 0 && z3[i-1][j] == z3[i][j] && m == 0) 
							{
								m = z3[i][j];
								z3[i-1][j] = 2*z3[i][j]; point += z3[i-1][j];
								z3[i][j] = 0;
								k = 1;
							}
							if(z3[i-1][j] != 0 && z3[i-1][j] == z3[i][j] && m != 0 && z3[i][j] == m)//无空位，已经进行过合并，数字相同
							{
								z3[i-1][j] = 2*z3[i][j]; point += z3[i-1][j]; 
								z3[i][j] = 0;
								k = 1;
							}
					    }
				    }
			    }
			
			for(i = 0;i < 3;i++)
			{
				for(j = 0;j < 3;j++)
				{
					c[i][j] = z3[2-i][j];			
				}
			}
		}
	
		if(b == 4)//向右的移动操作 
		{
		     for(i = 0;i < 3;i++)
			    {
				    for(j = 0;j < 3;j++)
				    {
					    z3[i][j] = c[j][2-i];			
				    }
			    }
			
			   for(j=0;j<3;j++)
			   {
				    m = 0;
					for(pass=1;pass<=2;pass++)
					{
						for(i=1;i<3;i++)
						{
							if(z3[i-1][j] == 0 && z3[i][j] != 0)
							{
								z3[i-1][j] = z3[i][j];
								z3[i][j] = 0;
								k = 1;
							}
							if(z3[i-1][j] != 0 && z3[i-1][j] == z3[i][j] && m == 0)
							{
								m = z3[i][j];
								z3[i-1][j] = 2*z3[i][j]; point += z3[i-1][j];
								z3[i][j] = 0;
								k = 1;
							}
							if(z3[i-1][j] != 0 && z3[i-1][j] == z3[i][j] && m != 0 && z3[i][j] == m)
							{
								z3[i-1][j] = 2*z3[i][j]; point += z3[i-1][j]; 
								z3[i][j] = 0;
								k = 1;
							}
					    }
				    }
			    }
			
			for(i = 0;i < 3;i++)
			{
				for(j = 0;j < 3;j++)
				{
					c[i][j] = z3[2-j][i];			
				}
			}
		}
	return k;
} 


int moveandadd4()
//4*4标准情况 
//moveandadd函数用于进行移动和数字相加的操作
//返回1表示进行了移动，返回0表示未进行移动 
{
	int k = 0;//k是预设返回值
	int i,j,pass,m;//i表示形式参数行，j表示形式参数列，pass表示检测的轮数,m表示是否进行了合并 
	    if(b == 1)//向上的移动操作 
		{
			for(i = 0;i < 4;i++)
			{
				for(j = 0;j < 4;j++)
				{
					z[i][j] = a[i][j];			
				}
			}
			
			for(j=0;j<4;j++)
			{
				m = 0;//m=0表示没有进行合并，m不为零表示两个相同的数字合并前其中一个是什么（即表示合并的类型，允许出现2222的两次合并，但不允许出现224的合并再合并）
				if(z[0][j] == z[1][j] && z[2][j] == z[3][j] && z[0][j] != 0 && z[2][j] != 0)//考虑2244的情况，原先的代码会变成228
				{
					z[0][j] = 2*z[0][j]; point += z[0][j];
					z[1][j] = 2*z[2][j]; point += z[1][j];
					z[2][j] = 0;
					z[3][j] = 0;
					k = 1;
				 } 
				else
				{
					for(pass=1;pass<=3;pass++)
					{
						for(i=1;i<4;i++)
						{
							if(z[i-1][j] == 0 && z[i][j] != 0)//有空位，上移 
							{
								z[i-1][j] = z[i][j];
								z[i][j] = 0;
								k = 1;
							}
							if(z[i-1][j] != 0 && z[i-1][j] == z[i][j] && m == 0)//无空位，还没有进行过合并，数字相同，合并相加并记录合并的类型 
							{
								m = z[i][j];
								z[i-1][j] = 2*z[i][j]; point += z[i-1][j];
								z[i][j] = 0;
								k = 1;
							}
							if(z[i-1][j] != 0 && z[i-1][j] == z[i][j] && m != 0 && z[i][j] == m)//无空位，已经进行过合并，数字相同
							{
								z[i-1][j] = 2*z[i][j]; point += z[i-1][j]; 
								z[i][j] = 0;
								k = 1;
							}
						}
					}
				}
			}
			
			for(i = 0;i < 4;i++)
			{
				for(j = 0;j < 4;j++)
				{
					a[i][j] = z[i][j];			
				}
			}
		}
		
		if(b == 2)//向左的移动操作 
		{
	        for(i = 0;i < 4;i++)
			{
				for(j = 0;j < 4;j++)
				{
					z[i][j] = a[j][i];			
				}
			}
			
			for(j=0;j<4;j++)
			{
				m = 0;//m=0表示没有进行合并，m不为零表示两个相同的数字合并前其中一个是什么（即表示合并的类型，允许出现2222的两次合并，但不允许出现224的合并再合并）
				if(z[0][j] == z[1][j] && z[2][j] == z[3][j] && z[0][j] != 0 && z[2][j] != 0)//考虑2244的情况，原先的代码会变成228
				{
					z[0][j] = 2*z[0][j]; point += z[0][j];
					z[1][j] = 2*z[2][j]; point += z[1][j];
					z[2][j] = 0;
					z[3][j] = 0;
					k = 1;
				 } 
				else
				{
					for(pass=1;pass<=4;pass++)
					{
						for(i=1;i<4;i++)
						{
							if(z[i-1][j] == 0 && z[i][j] != 0)//有空位，上移 
							{
								z[i-1][j] = z[i][j];
								z[i][j] = 0;
								k = 1;
							}
							if(z[i-1][j] != 0 && z[i-1][j] == z[i][j] && m == 0)//无空位，还没有进行过合并，数字相同，合并相加并记录合并的类型 
							{
								m = z[i][j];
								z[i-1][j] = 2*z[i][j]; point += z[i-1][j];
								z[i][j] = 0;
								k = 1;
							}
							if(z[i-1][j] != 0 && z[i-1][j] == z[i][j] && m != 0 && z[i][j] == m)//无空位，已经进行过合并，数字相同
							{
								z[i-1][j] = 2*z[i][j]; point += z[i-1][j]; 
								z[i][j] = 0;
								k = 1;
							}
						}
					}
				}
			}
			
			for(i = 0;i < 4;i++)
			{
				for(j = 0;j < 4;j++)
				{
					a[i][j] = z[j][i];			
				}
			}
		}
	
		if(b == 3)//向下的移动操作 
		{
		    for(i = 0;i < 4;i++)
			{
				for(j = 0;j < 4;j++)
				{
					z[i][j] = a[3-i][j];			
				}
			}
			
			for(j=0;j<4;j++)
			{
				m = 0;//m=0表示没有进行合并，m不为零表示两个相同的数字合并前其中一个是什么（即表示合并的类型，允许出现2222的两次合并，但不允许出现224的合并再合并）
				if(z[0][j] == z[1][j] && z[2][j] == z[3][j] && z[0][j] != 0 && z[2][j] != 0)//考虑2244的情况，原先的代码会变成228
				{
					z[0][j] = 2*z[0][j]; point += z[0][j];
					z[1][j] = 2*z[2][j]; point += z[1][j];
					z[2][j] = 0;
					z[3][j] = 0;
					k = 1;
				 } 
				else
				{
					for(pass=1;pass<=4;pass++)
					{
						for(i=1;i<4;i++)
						{
							if(z[i-1][j] == 0 && z[i][j] != 0)//有空位，上移 
							{
								z[i-1][j] = z[i][j];
								z[i][j] = 0;
								k = 1;
							}
							if(z[i-1][j] != 0 && z[i-1][j] == z[i][j] && m == 0)//无空位，还没有进行过合并，数字相同，合并相加并记录合并的类型 
							{
								m = z[i][j];
								z[i-1][j] = 2*z[i][j]; point += z[i-1][j];
								z[i][j] = 0;
								k = 1;
							}
							if(z[i-1][j] != 0 && z[i-1][j] == z[i][j] && m != 0 && z[i][j] == m)//无空位，已经进行过合并，数字相同
							{
								z[i-1][j] = 2*z[i][j]; point += z[i-1][j]; 
								z[i][j] = 0;
								k = 1;
							}
						}
					}
				}
			}
			
			for(i = 0;i < 4;i++)
			{
				for(j = 0;j < 4;j++)
				{
					a[i][j] = z[3-i][j];			
				}
			}
		}
		
		if(b == 4)//向右的移动操作 
		{
		    for(i = 0;i < 4;i++)
			{
				for(j = 0;j < 4;j++)
				{
					z[i][j] = a[j][3-i];			
				}
			}
			
			for(j=0;j<4;j++)
			{
				m = 0;//m=0表示没有进行合并，m不为零表示两个相同的数字合并前其中一个是什么（即表示合并的类型，允许出现2222的两次合并，但不允许出现224的合并再合并）
				if(z[0][j] == z[1][j] && z[2][j] == z[3][j] && z[0][j] != 0 && z[2][j] != 0)//考虑2244的情况，原先的代码会变成228
				{
					z[0][j] = 2*z[0][j]; point += z[0][j];
					z[1][j] = 2*z[2][j]; point += z[1][j];
					z[2][j] = 0;
					z[3][j] = 0;
					k = 1;
				 } 
				else
				{
					for(pass=1;pass<=4;pass++)
					{
						for(i=1;i<4;i++)
						{
							if(z[i-1][j] == 0 && z[i][j] != 0)//有空位，上移 
							{
								z[i-1][j] = z[i][j];
								z[i][j] = 0;
								k = 1;
							}
							if(z[i-1][j] != 0 && z[i-1][j] == z[i][j] && m == 0)//无空位，还没有进行过合并，数字相同，合并相加并记录合并的类型 
							{
								m = z[i][j];
								z[i-1][j] = 2*z[i][j]; point += z[i-1][j];
								z[i][j] = 0;
								k = 1;
							}
							if(z[i-1][j] != 0 && z[i-1][j] == z[i][j] && m != 0 && z[i][j] == m)//无空位，已经进行过合并，数字相同
							{
								z[i-1][j] = 2*z[i][j]; point += z[i-1][j]; 
								z[i][j] = 0;
								k = 1;
							}
						}
					}
				}
			}
			
			for(i = 0;i < 4;i++)
			{
				for(j = 0;j < 4;j++)
				{
					a[i][j] = z[3-j][i];			
				}
			}
		}
	return k;
}


int moveandadd5()
//5*5情况
//moveandadd函数用于进行移动和数字相加的操作
//返回1表示进行了移动，返回0表示未进行移动 
{
	int k = 0;//k是预设返回值
	int i,j,pass,m;//i表示形式参数行，j表示形式参数列，pass表示检测的轮数,m表示是否进行了合并 
		if(b == 1)//向上的移动操作 
		{
			for(i = 0;i < 5;i++)
			{
				for(j = 0;j < 5;j++)
				{
					z5[i][j] = d[i][j];	
				}
			}
			
			for(j=0;j<5;j++)
			{
				m = 0;//m=0表示没有进行合并，m不为零表示两个相同的数字合并前其中一个是什么（即表示合并的类型，允许出现2222的两次合并，但不允许出现224的合并再合并）
				if(z5[0][j] == z5[1][j] && z5[2][j] == z5[3][j] && z5[0][j] != 0 && z5[2][j] != 0)//考虑2244的情况，原先的代码会变成228
				{
					z5[0][j] = 2*z5[0][j]; point += z5[0][j];
					z5[1][j] = 2*z5[2][j]; point += z5[1][j];
					z5[2][j] = z5[4][j];
					z5[3][j] = 0;
					z5[4][j] = 0;
					k = 1;
				} 
				else if(z5[0][j] == z5[1][j] && z5[3][j] == z5[4][j] && z5[0][j] != 0 && z5[3][j] != 0 && z5[2][j] != z5[3][j] && z5[2][j] != 0)
				{
					z5[0][j] = 2*z5[0][j]; point += z5[0][j];
				    z5[1][j] = z5[2][j];
					z5[2][j] = 2*z5[3][j]; point += z5[2][j];
					z5[3][j] = 0;
					z5[4][j] = 0;
					k = 1;
				} 
				else if(z5[0][j] == z5[1][j] && z5[3][j] == z5[4][j] && z5[0][j] != 0 && z5[3][j] != 0 && z5[2][j] != z5[3][j] && z5[2][j] == 0)
				{
					z5[0][j] = 2*z5[0][j]; point += z5[0][j];
					z5[1][j] = 2*z5[3][j]; point += z5[1][j];
					z5[2][j] = 0;
					z5[3][j] = 0;
					z5[4][j] = 0;
					k = 1;
				} 
				else if(z5[1][j] == z5[2][j] && z5[3][j] == z5[4][j] && z5[1][j] != 0 && z5[4][j] != 0 && z5[0][j] != z5[1][j] && z5[0][j] != 0)
				{
					z5[0][j] = z5[0][j];
					z5[1][j] = 2*z5[1][j]; point += z5[1][j];
					z5[2][j] = 2*z5[3][j]; point += z5[2][j];
					z5[3][j] = 0;
					z5[4][j] = 0;
					k = 1;
				} 
				else if(z5[1][j] == z5[2][j] && z5[3][j] == z5[4][j] && z5[1][j] != 0 && z5[4][j] != 0 && z5[0][j] != z5[1][j] && z5[0][j] == 0)
				{
					z5[0][j] = 2*z5[1][j]; point += z5[0][j];
					z5[1][j] = 2*z5[3][j]; point += z5[1][j];
					z5[2][j] = 0;
					z5[3][j] = 0;
					z5[4][j] = 0;
					k = 1;
				} 
				else
				{
					for(pass=1;pass<=4;pass++)
					{
						for(i=1;i<5;i++)
						{
							if(z5[i-1][j] == 0 && z5[i][j] != 0)//有空位，上移 
							{
								z5[i-1][j] = z5[i][j];
								z5[i][j] = 0;
								k = 1;
							}
							if(z5[i-1][j] != 0 && z5[i-1][j] == z5[i][j] && m == 0)//无空位，还没有进行过合并，数字相同，合并相加并记录合并的类型 
							{
								m = z5[i][j];
								z5[i-1][j] = 2*z5[i][j]; point += z5[i-1][j];
								z5[i][j] = 0;
								k = 1;
							}
							if(z5[i-1][j] != 0 && z5[i-1][j] == z5[i][j] && m != 0 && z5[i][j] == m)//无空位，已经进行过合并，数字相同
							{
								z5[i-1][j] = 2*z5[i][j]; point += z5[i-1][j];
								z5[i][j] = 0;
								k = 1;
							}
						}
					}
				}
			}
				
			for(i = 0;i < 5;i++)
			{
				for(j = 0;j < 5;j++)
				{
					d[i][j] = z5[i][j];			
				}
			}
		}
    
        if(b == 2)
        {
            for(i = 0;i < 5;i++)
			{
				for(j = 0;j < 5;j++)
				{
					z5[i][j] = d[j][i];			
				}
			}
			
			for(j=0;j<5;j++)
			{
				m = 0;//m=0表示没有进行合并，m不为零表示两个相同的数字合并前其中一个是什么（即表示合并的类型，允许出现2222的两次合并，但不允许出现224的合并再合并）
				if(z5[0][j] == z5[1][j] && z5[2][j] == z5[3][j] && z5[0][j] != 0 && z5[2][j] != 0)//考虑2244的情况，原先的代码会变成228
				{
					z5[0][j] = 2*z5[0][j]; point += z5[0][j];
					z5[1][j] = 2*z5[2][j]; point += z5[1][j];
					z5[2][j] = z5[4][j];
					z5[3][j] = 0;
					z5[4][j] = 0;
					k = 1;
				} 
				else if(z5[0][j] == z5[1][j] && z5[3][j] == z5[4][j] && z5[0][j] != 0 && z5[3][j] != 0 && z5[2][j] != z5[3][j] && z5[2][j] != 0)
				{
					z5[0][j] = 2*z5[0][j]; point += z5[0][j];
				    z5[1][j] = z5[2][j];
					z5[2][j] = 2*z5[3][j]; point += z5[2][j];
					z5[3][j] = 0;
					z5[4][j] = 0;
					k = 1;
				} 
				else if(z5[0][j] == z5[1][j] && z5[3][j] == z5[4][j] && z5[0][j] != 0 && z5[3][j] != 0 && z5[2][j] != z5[3][j] && z5[2][j] == 0)
				{
					z5[0][j] = 2*z5[0][j]; point += z5[0][j];
					z5[1][j] = 2*z5[3][j]; point += z5[1][j];
					z5[2][j] = 0;
					z5[3][j] = 0;
					z5[4][j] = 0;
					k = 1;
				} 
				else if(z5[1][j] == z5[2][j] && z5[3][j] == z5[4][j] && z5[1][j] != 0 && z5[4][j] != 0 && z5[0][j] != z5[1][j] && z5[0][j] != 0)
				{
					z5[0][j] = z5[0][j];
					z5[1][j] = 2*z5[1][j]; point += z5[1][j];
					z5[2][j] = 2*z5[3][j]; point += z5[2][j];
					z5[3][j] = 0;
					z5[4][j] = 0;
					k = 1;
				} 
				else if(z5[1][j] == z5[2][j] && z5[3][j] == z5[4][j] && z5[1][j] != 0 && z5[4][j] != 0 && z5[0][j] != z5[1][j] && z5[0][j] == 0)
				{
					z5[0][j] = 2*z5[1][j]; point += z5[0][j];
					z5[1][j] = 2*z5[3][j]; point += z5[1][j];
					z5[2][j] = 0;
					z5[3][j] = 0;
					z5[4][j] = 0;
					k = 1;
				} 
				else
				{
					for(pass=1;pass<=4;pass++)
					{
						for(i=1;i<5;i++)
						{
							if(z5[i-1][j] == 0 && z5[i][j] != 0)//有空位，上移 
							{
								z5[i-1][j] = z5[i][j];
								z5[i][j] = 0;
								k = 1;
							}
							if(z5[i-1][j] != 0 && z5[i-1][j] == z5[i][j] && m == 0)//无空位，还没有进行过合并，数字相同，合并相加并记录合并的类型 
							{
								m = z5[i][j];
								z5[i-1][j] = 2*z5[i][j]; point += z5[i-1][j];
								z5[i][j] = 0;
								k = 1;
							}
							if(z5[i-1][j] != 0 && z5[i-1][j] == z5[i][j] && m != 0 && z5[i][j] == m)//无空位，已经进行过合并，数字相同
							{
								z5[i-1][j] = 2*z5[i][j]; point += z5[i-1][j]; 
								z5[i][j] = 0;
								k = 1;
							}
						}
					}
				}
			}
			
			for(i = 0;i < 5;i++)
			{
				for(j = 0;j < 5;j++)
				{
					d[i][j] = z5[j][i];			
				}
			}	
		}
		
		if(b == 3)
        {
	        	for(i = 0;i < 5;i++)
			{
				for(j = 0;j < 5;j++)
				{
					z5[i][j] = d[4-i][j];			
				}
			}
			
			for(j=0;j<5;j++)
			{
				m = 0;//m=0表示没有进行合并，m不为零表示两个相同的数字合并前其中一个是什么（即表示合并的类型，允许出现2222的两次合并，但不允许出现224的合并再合并）
				if(z5[0][j] == z5[1][j] && z5[2][j] == z5[3][j] && z5[0][j] != 0 && z5[2][j] != 0)//考虑2244的情况，原先的代码会变成228
				{
					z5[0][j] = 2*z5[0][j]; point += z5[0][j];
					z5[1][j] = 2*z5[2][j]; point += z5[1][j];
					z5[2][j] = z5[4][j];
					z5[3][j] = 0;
					z5[4][j] = 0;
					k = 1;
				} 
				else if(z5[0][j] == z5[1][j] && z5[3][j] == z5[4][j] && z5[0][j] != 0 && z5[3][j] != 0 && z5[2][j] != z5[3][j] && z5[2][j] != 0)
				{
					z5[0][j] = 2*z5[0][j]; point += z5[0][j];
				    z5[1][j] = z5[2][j];
					z5[2][j] = 2*z5[3][j]; point += z5[2][j];
					z5[3][j] = 0;
					z5[4][j] = 0;
					k = 1;
				} 
				else if(z5[0][j] == z5[1][j] && z5[3][j] == z5[4][j] && z5[0][j] != 0 && z5[3][j] != 0 && z5[2][j] != z5[3][j] && z5[2][j] == 0)
				{
					z5[0][j] = 2*z5[0][j]; point += z5[0][j];
					z5[1][j] = 2*z5[3][j]; point += z5[1][j];
					z5[2][j] = 0;
					z5[3][j] = 0;
					z5[4][j] = 0;
					k = 1;
				} 
				else if(z5[1][j] == z5[2][j] && z5[3][j] == z5[4][j] && z5[1][j] != 0 && z5[4][j] != 0 && z5[0][j] != z5[1][j] && z5[0][j] != 0)
				{
					z5[0][j] = z5[0][j];
					z5[1][j] = 2*z5[1][j]; point += z5[1][j];
					z5[2][j] = 2*z5[3][j]; point += z5[2][j];
					z5[3][j] = 0;
					z5[4][j] = 0;
					k = 1;
				} 
				else if(z5[1][j] == z5[2][j] && z5[3][j] == z5[4][j] && z5[1][j] != 0 && z5[4][j] != 0 && z5[0][j] != z5[1][j] && z5[0][j] == 0)
				{
					z5[0][j] = 2*z5[1][j]; point += z5[0][j];
					z5[1][j] = 2*z5[3][j]; point += z5[1][j];
					z5[2][j] = 0;
					z5[3][j] = 0;
					z5[4][j] = 0;
					k = 1;
				} 
				else
				{
					for(pass=1;pass<=4;pass++)
					{
						for(i=1;i<5;i++)
						{
							if(z5[i-1][j] == 0 && z5[i][j] != 0)//有空位，上移 
							{
								z5[i-1][j] = z5[i][j];
								z5[i][j] = 0;
								k = 1;
							}
							if(z5[i-1][j] != 0 && z5[i-1][j] == z5[i][j] && m == 0)//无空位，还没有进行过合并，数字相同，合并相加并记录合并的类型 
							{
								m = z5[i][j];
								z5[i-1][j] = 2*z5[i][j]; point += z5[i-1][j];
								z5[i][j] = 0;
								k = 1;
							}
							if(z5[i-1][j] != 0 && z5[i-1][j] == z5[i][j] && m != 0 && z5[i][j] == m)//无空位，已经进行过合并，数字相同
							{
								z5[i-1][j] = 2*z5[i][j]; point += z5[i-1][j]; 
								z5[i][j] = 0;
								k = 1;
							}
						}
					}
				}
			}
			
			for(i = 0;i < 5;i++)
			{
				for(j = 0;j < 5;j++)
				{
					d[i][j] = z5[4-i][j];			
				}
			}
			}
			
			if(b == 4)
	        {
	            for(i = 0;i < 5;i++)
			{
				for(j = 0;j < 5;j++)
				{
					z5[i][j] = d[j][4-i];			
				}
			}
			
			for(j=0;j<5;j++)
			{
				m = 0;//m=0表示没有进行合并，m不为零表示两个相同的数字合并前其中一个是什么（即表示合并的类型，允许出现2222的两次合并，但不允许出现224的合并再合并）
				if(z5[0][j] == z5[1][j] && z5[2][j] == z5[3][j] && z5[0][j] != 0 && z5[2][j] != 0)//考虑2244的情况，原先的代码会变成228
				{
					z5[0][j] = 2*z5[0][j]; point += z5[0][j];
					z5[1][j] = 2*z5[2][j]; point += z5[1][j];
					z5[2][j] = z5[4][j];
					z5[3][j] = 0;
					z5[4][j] = 0;
					k = 1;
				} 
				else if(z5[0][j] == z5[1][j] && z5[3][j] == z5[4][j] && z5[0][j] != 0 && z5[3][j] != 0 && z5[2][j] != z5[3][j] && z5[2][j] != 0)
				{
					z5[0][j] = 2*z5[0][j]; point += z5[0][j];
				    z5[1][j] = z5[2][j];
					z5[2][j] = 2*z5[3][j]; point += z5[2][j];
					z5[3][j] = 0;
					z5[4][j] = 0;
					k = 1;
				} 
				else if(z5[0][j] == z5[1][j] && z5[3][j] == z5[4][j] && z5[0][j] != 0 && z5[3][j] != 0 && z5[2][j] != z5[3][j] && z5[2][j] == 0)
				{
					z5[0][j] = 2*z5[0][j]; point += z5[0][j];
					z5[1][j] = 2*z5[3][j]; point += z5[1][j];
					z5[2][j] = 0;
					z5[3][j] = 0;
					z5[4][j] = 0;
					k = 1;
				} 
				else if(z5[1][j] == z5[2][j] && z5[3][j] == z5[4][j] && z5[1][j] != 0 && z5[4][j] != 0 && z5[0][j] != z5[1][j] && z5[0][j] != 0)
				{
					z5[0][j] = z5[0][j];
					z5[1][j] = 2*z5[1][j]; point += z5[1][j];
					z5[2][j] = 2*z5[3][j]; point += z5[2][j];
					z5[3][j] = 0;
					z5[4][j] = 0;
					k = 1;
				} 
				else if(z5[1][j] == z5[2][j] && z5[3][j] == z5[4][j] && z5[1][j] != 0 && z5[4][j] != 0 && z5[0][j] != z5[1][j] && z5[0][j] == 0)
				{
					z5[0][j] = 2*z5[1][j]; point += z5[0][j];
					z5[1][j] = 2*z5[3][j]; point += z5[1][j];
					z5[2][j] = 0;
					z5[3][j] = 0;
					z5[4][j] = 0;
					k = 1;
				} 
				else
				{
					for(pass=1;pass<=4;pass++)
					{
						for(i=1;i<5;i++)
						{
							if(z5[i-1][j] == 0 && z5[i][j] != 0)//有空位，上移 
							{
								z5[i-1][j] = z5[i][j];
								z5[i][j] = 0;
								k = 1;
							}
							if(z5[i-1][j] != 0 && z5[i-1][j] == z5[i][j] && m == 0)//无空位，还没有进行过合并，数字相同，合并相加并记录合并的类型 
							{
								m = z5[i][j];
								z5[i-1][j] = 2*z5[i][j]; point += z5[i-1][j];
								z5[i][j] = 0;
								k = 1;
							}
							if(z5[i-1][j] != 0 && z5[i-1][j] == z5[i][j] && m != 0 && z5[i][j] == m)//无空位，已经进行过合并，数字相同
							{
								z5[i-1][j] = 2*z5[i][j]; point += z5[i-1][j]; 
								z5[i][j] = 0;
								k = 1;
							}
						}
					}
				}
			}
			
			for(i = 0;i < 5;i++)
			{
				for(j = 0;j < 5;j++)
				{
					d[i][j] = z5[4-j][i];			
				}
			}	
		}
	return k;
}

int moveandadd40()
//不改变 point值的 moveandadd函数 
//4*4标准情况 
//moveandadd函数用于进行移动和数字相加的操作
//返回1表示进行了移动，返回0表示未进行移动 
{
	int k = 0;//k是预设返回值
	int i,j,pass,m;//i表示形式参数行，j表示形式参数列，pass表示检测的轮数,m表示是否进行了合并 
	    if(b == 1)//向上的移动操作 
		{
			for(i = 0;i < 4;i++)
			{
				for(j = 0;j < 4;j++)
				{
					z[i][j] = a[i][j];			
				}
			}
			
			for(j=0;j<4;j++)
			{
				m = 0;//m=0表示没有进行合并，m不为零表示两个相同的数字合并前其中一个是什么（即表示合并的类型，允许出现2222的两次合并，但不允许出现224的合并再合并）
				if(z[0][j] == z[1][j] && z[2][j] == z[3][j] && z[0][j] != 0 && z[2][j] != 0)//考虑2244的情况，原先的代码会变成228
				{
					z[0][j] = 2*z[0][j];
					z[1][j] = 2*z[2][j];
					z[2][j] = 0;
					z[3][j] = 0;
					k = 1;
				 } 
				else
				{
					for(pass=1;pass<=3;pass++)
					{
						for(i=1;i<4;i++)
						{
							if(z[i-1][j] == 0 && z[i][j] != 0)//有空位，上移 
							{
								z[i-1][j] = z[i][j];
								z[i][j] = 0;
								k = 1;
							}
							if(z[i-1][j] != 0 && z[i-1][j] == z[i][j] && m == 0)//无空位，还没有进行过合并，数字相同，合并相加并记录合并的类型 
							{
								m = z[i][j];
								z[i-1][j] = 2*z[i][j];
								z[i][j] = 0;
								k = 1;
							}
							if(z[i-1][j] != 0 && z[i-1][j] == z[i][j] && m != 0 && z[i][j] == m)//无空位，已经进行过合并，数字相同
							{
								z[i-1][j] = 2*z[i][j];
								z[i][j] = 0;
								k = 1;
							}
						}
					}
				}
			}
			
			for(i = 0;i < 4;i++)
			{
				for(j = 0;j < 4;j++)
				{
					a[i][j] = z[i][j];			
				}
			}
		}
		
		if(b == 2)//向左的移动操作 
		{
	        for(i = 0;i < 4;i++)
			{
				for(j = 0;j < 4;j++)
				{
					z[i][j] = a[j][i];			
				}
			}
			
			for(j=0;j<4;j++)
			{
				m = 0;//m=0表示没有进行合并，m不为零表示两个相同的数字合并前其中一个是什么（即表示合并的类型，允许出现2222的两次合并，但不允许出现224的合并再合并）
				if(z[0][j] == z[1][j] && z[2][j] == z[3][j] && z[0][j] != 0 && z[2][j] != 0)//考虑2244的情况，原先的代码会变成228
				{
					z[0][j] = 2*z[0][j];
					z[1][j] = 2*z[2][j];
					z[2][j] = 0;
					z[3][j] = 0;
					k = 1;
				 } 
				else
				{
					for(pass=1;pass<=4;pass++)
					{
						for(i=1;i<4;i++)
						{
							if(z[i-1][j] == 0 && z[i][j] != 0)//有空位，上移 
							{
								z[i-1][j] = z[i][j];
								z[i][j] = 0;
								k = 1;
							}
							if(z[i-1][j] != 0 && z[i-1][j] == z[i][j] && m == 0)//无空位，还没有进行过合并，数字相同，合并相加并记录合并的类型 
							{
								m = z[i][j];
								z[i-1][j] = 2*z[i][j];
								z[i][j] = 0;
								k = 1;
							}
							if(z[i-1][j] != 0 && z[i-1][j] == z[i][j] && m != 0 && z[i][j] == m)//无空位，已经进行过合并，数字相同
							{
								z[i-1][j] = 2*z[i][j]; 
								z[i][j] = 0;
								k = 1;
							}
						}
					}
				}
			}
			
			for(i = 0;i < 4;i++)
			{
				for(j = 0;j < 4;j++)
				{
					a[i][j] = z[j][i];			
				}
			}
		}
	
		if(b == 3)//向下的移动操作 
		{
		    for(i = 0;i < 4;i++)
			{
				for(j = 0;j < 4;j++)
				{
					z[i][j] = a[3-i][j];			
				}
			}
			
			for(j=0;j<4;j++)
			{
				m = 0;//m=0表示没有进行合并，m不为零表示两个相同的数字合并前其中一个是什么（即表示合并的类型，允许出现2222的两次合并，但不允许出现224的合并再合并）
				if(z[0][j] == z[1][j] && z[2][j] == z[3][j] && z[0][j] != 0 && z[2][j] != 0)//考虑2244的情况，原先的代码会变成228
				{
					z[0][j] = 2*z[0][j];
					z[1][j] = 2*z[2][j];
					z[2][j] = 0;
					z[3][j] = 0;
					k = 1;
				 } 
				else
				{
					for(pass=1;pass<=4;pass++)
					{
						for(i=1;i<4;i++)
						{
							if(z[i-1][j] == 0 && z[i][j] != 0)//有空位，上移 
							{
								z[i-1][j] = z[i][j];
								z[i][j] = 0;
								k = 1;
							}
							if(z[i-1][j] != 0 && z[i-1][j] == z[i][j] && m == 0)//无空位，还没有进行过合并，数字相同，合并相加并记录合并的类型 
							{
								m = z[i][j];
								z[i-1][j] = 2*z[i][j];
								z[i][j] = 0;
								k = 1;
							}
							if(z[i-1][j] != 0 && z[i-1][j] == z[i][j] && m != 0 && z[i][j] == m)//无空位，已经进行过合并，数字相同
							{
								z[i-1][j] = 2*z[i][j];
								z[i][j] = 0;
								k = 1;
							}
						}
					}
				}
			}
			
			for(i = 0;i < 4;i++)
			{
				for(j = 0;j < 4;j++)
				{
					a[i][j] = z[3-i][j];			
				}
			}
		}
		
		if(b == 4)//向右的移动操作 
		{
		    for(i = 0;i < 4;i++)
			{
				for(j = 0;j < 4;j++)
				{
					z[i][j] = a[j][3-i];			
				}
			}
			
			for(j=0;j<4;j++)
			{
				m = 0;//m=0表示没有进行合并，m不为零表示两个相同的数字合并前其中一个是什么（即表示合并的类型，允许出现2222的两次合并，但不允许出现224的合并再合并）
				if(z[0][j] == z[1][j] && z[2][j] == z[3][j] && z[0][j] != 0 && z[2][j] != 0)//考虑2244的情况，原先的代码会变成228
				{
					z[0][j] = 2*z[0][j];
					z[1][j] = 2*z[2][j];
					z[2][j] = 0;
					z[3][j] = 0;
					k = 1;
				 } 
				else
				{
					for(pass=1;pass<=4;pass++)
					{
						for(i=1;i<4;i++)
						{
							if(z[i-1][j] == 0 && z[i][j] != 0)//有空位，上移 
							{
								z[i-1][j] = z[i][j];
								z[i][j] = 0;
								k = 1;
							}
							if(z[i-1][j] != 0 && z[i-1][j] == z[i][j] && m == 0)//无空位，还没有进行过合并，数字相同，合并相加并记录合并的类型 
							{
								m = z[i][j];
								z[i-1][j] = 2*z[i][j];
								z[i][j] = 0;
								k = 1;
							}
							if(z[i-1][j] != 0 && z[i-1][j] == z[i][j] && m != 0 && z[i][j] == m)//无空位，已经进行过合并，数字相同
							{
								z[i-1][j] = 2*z[i][j];
								z[i][j] = 0;
								k = 1;
							}
						}
					}
				}
			}
			
			for(i = 0;i < 4;i++)
			{
				for(j = 0;j < 4;j++)
				{
					a[i][j] = z[3-j][i];			
				}
			}
		}
	return k;
}


int moveandadd41()
//不改变 point值，但改变 point1值的 moveandadd函数 
//4*4标准情况 
//moveandadd函数用于进行移动和数字相加的操作
//返回1表示进行了移动，返回0表示未进行移动 
{
	point1 = point;
	int k = 0;//k是预设返回值
	int i, j, pass, m;//i表示形式参数行，j表示形式参数列，pass表示检测的轮数,m表示是否进行了合并 
	if (b == 1)//向上的移动操作 
	{
		for (i = 0; i < 4; i++)
		{
			for (j = 0; j < 4; j++)
			{
				z[i][j] = a[i][j];
			}
		}

		for (j = 0; j < 4; j++)
		{
			m = 0;//m=0表示没有进行合并，m不为零表示两个相同的数字合并前其中一个是什么（即表示合并的类型，允许出现2222的两次合并，但不允许出现224的合并再合并）
			if (z[0][j] == z[1][j] && z[2][j] == z[3][j] && z[0][j] != 0 && z[2][j] != 0)//考虑2244的情况，原先的代码会变成228
			{
				z[0][j] = 2 * z[0][j]; point1 += z[0][j];
				z[1][j] = 2 * z[2][j]; point1 += z[1][j];
				z[2][j] = 0;
				z[3][j] = 0;
				k = 1;
			}
			else
			{
				for (pass = 1; pass <= 3; pass++)
				{
					for (i = 1; i < 4; i++)
					{
						if (z[i - 1][j] == 0 && z[i][j] != 0)//有空位，上移 
						{
							z[i - 1][j] = z[i][j];
							z[i][j] = 0;
							k = 1;
						}
						if (z[i - 1][j] != 0 && z[i - 1][j] == z[i][j] && m == 0)//无空位，还没有进行过合并，数字相同，合并相加并记录合并的类型 
						{
							m = z[i][j];
							z[i - 1][j] = 2 * z[i][j]; point1 += z[i - 1][j];
							z[i][j] = 0;
							k = 1;
						}
						if (z[i - 1][j] != 0 && z[i - 1][j] == z[i][j] && m != 0 && z[i][j] == m)//无空位，已经进行过合并，数字相同
						{
							z[i - 1][j] = 2 * z[i][j]; point1 += z[i - 1][j];
							z[i][j] = 0;
							k = 1;
						}
					}
				}
			}
		}

		for (i = 0; i < 4; i++)
		{
			for (j = 0; j < 4; j++)
			{
				a[i][j] = z[i][j];
			}
		}
	}

	if (b == 2)//向左的移动操作 
	{
		for (i = 0; i < 4; i++)
		{
			for (j = 0; j < 4; j++)
			{
				z[i][j] = a[j][i];
			}
		}

		for (j = 0; j < 4; j++)
		{
			m = 0;//m=0表示没有进行合并，m不为零表示两个相同的数字合并前其中一个是什么（即表示合并的类型，允许出现2222的两次合并，但不允许出现224的合并再合并）
			if (z[0][j] == z[1][j] && z[2][j] == z[3][j] && z[0][j] != 0 && z[2][j] != 0)//考虑2244的情况，原先的代码会变成228
			{
				z[0][j] = 2 * z[0][j]; point1 += z[0][j];
				z[1][j] = 2 * z[2][j]; point1 += z[1][j];
				z[2][j] = 0;
				z[3][j] = 0;
				k = 1;
			}
			else
			{
				for (pass = 1; pass <= 4; pass++)
				{
					for (i = 1; i < 4; i++)
					{
						if (z[i - 1][j] == 0 && z[i][j] != 0)//有空位，上移 
						{
							z[i - 1][j] = z[i][j];
							z[i][j] = 0;
							k = 1;
						}
						if (z[i - 1][j] != 0 && z[i - 1][j] == z[i][j] && m == 0)//无空位，还没有进行过合并，数字相同，合并相加并记录合并的类型 
						{
							m = z[i][j];
							z[i - 1][j] = 2 * z[i][j]; point1 += z[i - 1][j];
							z[i][j] = 0;
							k = 1;
						}
						if (z[i - 1][j] != 0 && z[i - 1][j] == z[i][j] && m != 0 && z[i][j] == m)//无空位，已经进行过合并，数字相同
						{
							z[i - 1][j] = 2 * z[i][j]; point1 += z[i - 1][j];
							z[i][j] = 0;
							k = 1;
						}
					}
				}
			}
		}

		for (i = 0; i < 4; i++)
		{
			for (j = 0; j < 4; j++)
			{
				a[i][j] = z[j][i];
			}
		}
	}

	if (b == 3)//向下的移动操作 
	{
		for (i = 0; i < 4; i++)
		{
			for (j = 0; j < 4; j++)
			{
				z[i][j] = a[3 - i][j];
			}
		}

		for (j = 0; j < 4; j++)
		{
			m = 0;//m=0表示没有进行合并，m不为零表示两个相同的数字合并前其中一个是什么（即表示合并的类型，允许出现2222的两次合并，但不允许出现224的合并再合并）
			if (z[0][j] == z[1][j] && z[2][j] == z[3][j] && z[0][j] != 0 && z[2][j] != 0)//考虑2244的情况，原先的代码会变成228
			{
				z[0][j] = 2 * z[0][j]; point1 += z[0][j];
				z[1][j] = 2 * z[2][j]; point1 += z[1][j];
				z[2][j] = 0;
				z[3][j] = 0;
				k = 1;
			}
			else
			{
				for (pass = 1; pass <= 4; pass++)
				{
					for (i = 1; i < 4; i++)
					{
						if (z[i - 1][j] == 0 && z[i][j] != 0)//有空位，上移 
						{
							z[i - 1][j] = z[i][j];
							z[i][j] = 0;
							k = 1;
						}
						if (z[i - 1][j] != 0 && z[i - 1][j] == z[i][j] && m == 0)//无空位，还没有进行过合并，数字相同，合并相加并记录合并的类型 
						{
							m = z[i][j];
							z[i - 1][j] = 2 * z[i][j]; point1 += z[i - 1][j];
							z[i][j] = 0;
							k = 1;
						}
						if (z[i - 1][j] != 0 && z[i - 1][j] == z[i][j] && m != 0 && z[i][j] == m)//无空位，已经进行过合并，数字相同
						{
							z[i - 1][j] = 2 * z[i][j]; point1 += z[i - 1][j];
							z[i][j] = 0;
							k = 1;
						}
					}
				}
			}
		}

		for (i = 0; i < 4; i++)
		{
			for (j = 0; j < 4; j++)
			{
				a[i][j] = z[3 - i][j];
			}
		}
	}

	if (b == 4)//向右的移动操作 
	{
		for (i = 0; i < 4; i++)
		{
			for (j = 0; j < 4; j++)
			{
				z[i][j] = a[j][3 - i];
			}
		}

		for (j = 0; j < 4; j++)
		{
			m = 0;//m=0表示没有进行合并，m不为零表示两个相同的数字合并前其中一个是什么（即表示合并的类型，允许出现2222的两次合并，但不允许出现224的合并再合并）
			if (z[0][j] == z[1][j] && z[2][j] == z[3][j] && z[0][j] != 0 && z[2][j] != 0)//考虑2244的情况，原先的代码会变成228
			{
				z[0][j] = 2 * z[0][j]; point1 += z[0][j];
				z[1][j] = 2 * z[2][j]; point1 += z[1][j];
				z[2][j] = 0;
				z[3][j] = 0;
				k = 1;
			}
			else
			{
				for (pass = 1; pass <= 4; pass++)
				{
					for (i = 1; i < 4; i++)
					{
						if (z[i - 1][j] == 0 && z[i][j] != 0)//有空位，上移 
						{
							z[i - 1][j] = z[i][j];
							z[i][j] = 0;
							k = 1;
						}
						if (z[i - 1][j] != 0 && z[i - 1][j] == z[i][j] && m == 0)//无空位，还没有进行过合并，数字相同，合并相加并记录合并的类型 
						{
							m = z[i][j];
							z[i - 1][j] = 2 * z[i][j]; point1 += z[i - 1][j];
							z[i][j] = 0;
							k = 1;
						}
						if (z[i - 1][j] != 0 && z[i - 1][j] == z[i][j] && m != 0 && z[i][j] == m)//无空位，已经进行过合并，数字相同
						{
							z[i - 1][j] = 2 * z[i][j]; point1 += z[i - 1][j];
							z[i][j] = 0;
							k = 1;
						}
					}
				}
			}
		}

		for (i = 0; i < 4; i++)
		{
			for (j = 0; j < 4; j++)
			{
				a[i][j] = z[3 - j][i];
			}
		}
	}
	return point1;
}


int moveandadd()
//moveandadd函数用于进行移动和数字相加的操作
//返回1表示进行了移动，返回0表示未进行移动 
{
	int k = 0;//k是预设返回值
	//3*3的情况 
	if(N == 3)
	{
		k = moveandadd3();
	}
	//4*4的标准情况 
	if(N == 4)
	{
	    k = moveandadd4();
	}
	//5*5的情况 
	if(N == 5)
	{
		k = moveandadd5();
    }
	return k;
}

int change(char c)
//将操作字符换成1234的数字 
{
	if(c == 'w' || c == 'W') return 1;
	if(c == 'a' || c == 'A') return 2;
	if(c == 's' || c == 'S') return 3;
	if(c == 'd' || c == 'D') return 4;
}

